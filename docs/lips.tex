%
% Copyright 2022-2023 Krister Joas
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%     http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%
\documentclass[a4paper]{article}
\usepackage{slantsc}
\usepackage{lmodern}
\usepackage{changepage}
\usepackage{enumitem}
\usepackage{listings}
\lstset{language=Lisp,
  basicstyle={\ttfamily},
  escapeinside={<>},
  mathescape=true,
  breaklines=true,
  breakatwhitespace=true
}
\newcommand{\lips}{\textsc{Lips}}
\newcommand{\lisp}[1]{\texttt{#1}}
\newcommand{\T}{\lisp{t}}
\newcommand{\NIL}{\lisp{nil}}
\newcommand{\cpp}[1]{\texttt{#1}}
\newcommand{\xargs}{$x_{1}$ $x_{2}$ $\cdots$}
\newcommand{\largs}{$x_{1}$, $x_{2}$, $\ldots$}
\newenvironment{examples}{
  \newcommand{\ex}[2]{
    \lisp{##1} $\Rightarrow$ \lisp{##2}\\
  }
  \begin{adjustwidth}{0.5cm}{}}{\end{adjustwidth}}
\newenvironment{defun}[2]{\begin{adjustwidth}{0.5cm}{}
    {\hspace*{-0.5cm}\lisp{#2}\hfill[\textit{#1}]\\}}
               {\end{adjustwidth}}
\newcommand{\example}[2]{
  \begin{adjustwidth}{0.2cm}{}
    \lisp{#1} $\Rightarrow$ \lisp{#2}
  \end{adjustwidth}
}
\setlist[description]{font=\normalfont\ttfamily}
\setlength\parskip{1em plus 0.1em minus 0.1em}
\setlength\parindent{0pt}

\title{\textsc{Lips} Reference Manual}
\author{Krister Joas}
\date{Version 2.0.3\\August, 2023}
\begin{document}
\maketitle

\newpage

Copyright \copyright 1988-1989, 1992, 2020-2023 Krister Joas

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You may
obtain a copy of the License at

\begin{quotation}
\texttt{http://www.apache.org/licenses/LICENSE-2.0}
\end{quotation}

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied.  See the License for the specific language governing
permissions and limitations under the License.

\newpage

\section{Introduction}

\lips\ is an embeddable lisp interpreter written in \textsf{C++-20}.
\lips\ is inspired by \textsc{Interlisp} and functions are usually
named as they are named in \textsc{Interlisp}.  Functions tend to
behave in the same way as they do in \textsc{Interlisp}.  There are
exceptions and \lips\ is not a faithful implementation of
\textsc{Interlisp} by any stretch.

\lips\ can be used as a stand alone lisp interpreter or as a library
linked with other applications.  Two such applicatins are includes as
examples.  One is a simple program containing a read-eval-print loop
which, after reading and evaluating the expressions in any file given
as arguments, prints a prompt, reads expressions, evaluates them, and
prints the result.

\lips\ also includes a proof of concept implementation of a command
shell.  The shell adds functions for program composition with pipes
and input/output redirection.  Read macros are used to transform the
input to make the input syntax resemble the standard shells.

This document is a reference manual for \lips\.  See section
\ref{functions} page \pageref{functions} for a complete list of lisp
functions provided.

\section{Lips Input Syntax}

The types of objects recognized by the lisp reader are integers,
floats, literal atoms, lists, and strings.  All objects except lists
and dotted pairs are called atoms.

Strings start and end with a double quote, `\lisp{"}'.  To enter a
double quote in a string precede it with a backslash, `\lisp{\char`\\}'.
For instance, \lisp{"Foo bar"} is a string and so is \lisp{"I like
  \char`\\"lips\char`\\""} which contains two double quotes.  Newlines
may be embedded inside strings without escaping them.

Lists start with a left parenthesis followed by zero or more lisp
expressions separated by separators (see below).  The list ends with a
matching right parenthesis.  Separators breaks the atoms, and by
default these are blanks, tabs, and newlines.  There is also a class
of characters called break characters.  These characters breaks
literal atoms and there is no need to add separators around them.
Break characters are also literal atoms.  The default break characters
are: `\lisp{(}', `\lisp{)}', `\lisp{\&}', `\lisp{<}', `\lisp{>}' and
`\lisp{|}'.  Thus,

\begin{quote}
  \lisp{foo\\
    (foo)\\
    (foo fie fum)\\
    (foo (fie (x y (z))) (fum))}
\end{quote}

are all valid lisp expressions.  The nesting of parenthesis may have
arbitrary depth.

\lips\ supports super parenthesis. Super parenthesis are square
brackets and when an opening square bracket is closed by a matching
closing square bracket any missing right round parenthesis is added. A
final closing square bracket closes any open round parenthesis and
finishes the expression. Here are some examples:

\begin{examples}
  \ex{(cond [(null nil) "hello"] (t "world"))}{"hello"}
  \ex{(cons 'a (cons 'b (cons 'c]}{(a b c)}
\end{examples}

The elements of lists are stored in the car part of the cons cells,
and are then linked together by the cdr's.  The last cdr is always
\NIL.  It's possible to enter so called dotted pairs in \lips.  A
dotted pair is a cons cell with two expressions with no restrictions
in the car and cdr of the cell.  Dotted pairs are entered starting
with a left parenthesis, a \lips\ expression, followed by a dot, `.',
another expression, and terminated with a right parenthesis.
\lisp{(a\ .\ b)} is an example of a dotted pair. Note that the blanks
around the dot are necessary, the dot is not a break character.  The
dot is recognized in this special way only if it occurs as the second
element from the end of a list.  In other cases it is treated as an
ordinary atom.  The list \lisp{(.\ .\ .\ .)} is a list with three
elements ending in a dotted pair.

A list is just a special case of dotted pairs.  \lisp{(a .\ (b
  .\ nil))} is equivalent to \lisp{(a b)}.  The second format is just
a convenience since lists are so common.

Integers consist of a sequence of digits.  No check for overflow is
made.  Floats are a bit complicated, but in most cases an atom that
looks like float is a float.  A float is a sequence of digits that
have either a decimal point or a exponentiation character, `e',
inside.  At most one decimal point is allowed.  If the exponentiation
character is given it must be followed by at least one digit.  If
these rules are not followed the atom will be interpreted as a literal
atom.

Examples:
\begin{tabbing}
\lisp{foo}\hspace*{1cm}\=literal atom\\
\lisp{"fie"}      \>string\\
\lisp{123}        \>integer\\
\lisp{12a}        \>literal atom\\
\lisp{1.0}        \>float\\
\lisp{1e5}        \>float\\
\lisp{1e}         \>literal atom\\
\lisp{.e4}        \>literal atom\\
\lisp{1.4.}       \>literal atom
\end{tabbing}

All expressions typed at the top level prompt are treated as lists.
This means that \lips\ supplies an extra pair of matching parenthesis
around all expressions.  If the first expression of a line is an atom,
and not a list, input terminates with either a return (providing that
parenthesis in subexpressions match), or an extra right parenthesis.
In the first case, a matching pair of parenthesis are added
surrounding the line, in the second case an extra left parenthesis is
added as the first character.  Again, if a left parenthesis is missing
a matching parenthesis is inserted.

Typing the outermost parenthesis explicitly will make \lips\ print out
the return value of the expression.  This is the way normal lisp
systems behave, but when used only as a command shell the return value
is most often uninteresting.  The return value is also stored in the
variable $value$.

Comments are allowed in \lips\ files.  In order to allow for the
\textsc{Unix} ``shebang'' interpreter directive a `\lisp{\#}'
character in the first column of a line is recognized as a comment
that ends with a newline. A \lisp{\#} in any other colmn is treated as
a regular character.  Comments may also start with the semicolon
character and the comment again continues until the end of the line.

\section{The Evaluation Process}
The \lips\ interpreter has ``dynamic scope'' and ``shallow'' binding.
``Dynamic scope'' means that free variables are looked up in the call
stack. For example:

\example{((lambda (a) ((lambda (b) (plus a b)) 1)) 2)}{3}

``Lexical scope'' can be simulated using the \lisp{closure} function
(see section \ref{closure} on page \pageref{closure}) which creates a
lexical scope for variables.

``Shallow'' binding means that every time a symbol is bound to a value
the previous value is pushed onto a stack.  The current value of an
atom is stored in the ``value cell'' and can be retrieved immediately.
The opposite of ``shallow'' binding, ``deep'' binding, in contrast has
to traverse the stack to find the current value of an atom.

In \lips\ there is no top level value.  There is also no ``function
definition cell'', only a ``value cell''.  Defining a function and
binding it to a symbol simply sets the value cell for that symbol.
Symbols are case sensitive and all system symbols are in lower case.
\lips\ does not use a stop and sweep garbage collector.  Instead
objects are reference counted and freed when the reference count goes
down to zero.

On the top level \lips\ reads expressions from standard in and
evaluates the expressions.  Commands entered on the top level are
always treated as functions, even if no parameters are given or if the
expression is a single atom.  In order to print the value of a
variable the function print must be used.

If the expression to be evaluated is a list the first element (the
car) in the list is evaluated and then applied to the arguments.  The
car of the expression is reevalutated until either a proper functional
form is recognized or if it's evaluated to an illegal functional form,
in which case an error is signalled.

If the functional form is an unbound atom, \lips\ looks for the
property \lips{autoload} on the property list of the atom.  If it is
found, and the value is a symbol or a string, the file with that name
is loaded (if possible).  The interpreter then checks if the atom is
no longer unbound, in wich case evaluation continues.  If the atom
doesn't have the \lips{autoload} property, or loading the file didn't
define the symbol, \lips\ looks under the property \lisp{alias}.  The
atom is replaced with the expression stored under that property, if
any, and the rest of the expression is appended at the end and the
evaluation process continues.  When all else fails it is assumed the
atom stands for an executable command.  The return value of an
executable command is, at present, always \T.

Note that the arguments for the command are never evaluated.  If you
want them evaluated you must use the function \lisp{apply}.

\section{Variables}
What follows is a list of all user accessable variables that in some
way guides the behavior of \lips.
\begin{description}
\item[histmax] Controls the number of commands to save on the history
  list.
\item[verboseflg] If verboseflg is non-\NIL, \lips\ prints some
  messages whenever a function is redefined or a variable is reset to
  a new value.
\item[path] The \lisp{path} variable contains a list of directories to
  be searched for executable programs.
\item[home] This variable contains the home directory of the user.
\item[history] In the \lisp{history} variable the history list is
  built.  This is for internal use and proper functioning of \lips\ is
  not garantueed if history is set to funny values.
\item[histnum] The variable \lisp{histnum} contains the number on the
  current \lips\ interaction.  The same warnings apply to histnum as
  to history.
\item[prompt] This variable contains the string that is printed as the
  prompt.  An exclamation mark is replaced with the current history
  number from \lisp{histnum}.  The default prompt is ``!\_''.
\item[brkprompt] Same as \lisp{prompt} but controls prompting in a break.
  The default is ``!:''.
\item[promptform] This variable is evaluated before the prompt is
  printed.  If an error occurs during evaluation of promptform it is
  reset to the default prompt.
\end{description}

\section{\lips\ as a Shell}
If a function is \lisp{unbound} the \lips\ shell tries to run the
function as an executable.  When \lips\ reads an expression some
characters are treated as read-macros.  A read-macro can expand or
transform the input in different ways.  The current version of the
reader in \lips\ isn't fully developed yet and it's likely to be
improved in later versions.

In addition to read-macros the input is also transformed using a hook
which is evaluated after an expression is read and before it's
evaluated.  For example, the input \lisp{ls | wc -l} is rewritten by
the transform hook into \lisp{(pipe-cmd (ls) (wc -l))}.  The
\lisp{pipe-cmd} function evaluates each expression in a separate
process, connecting the stdout from the \lisp{ls} function (i.e. the
\lisp{ls} command) to the stdin of the \lisp{wc} function (command).

Redirection of stdout and stdin is also handled by the transform hook.

\section{Using \lips\ as an Embedded Lisp Interpreter}
\subsection{Basic Usage}
The most basic types in \lips\ are the following.
\begin{itemize}
  \item \cpp{lisp::vm} The lisp interpreter, or virtual machine. There
    may be only one lisp interpreter in the same program.
  \item \cpp{lisp::context} The context contains some globally
    accessable values mostly related to I/O such as the current
    primary output or primary error. Currently there can be only one
    context per program.
  \item \cpp{lisp\_t} This is a basic type which can contain a value
    of several fundamental types. \cpp{lisp\_t} is a pointer to a
    reference counted object of type \cpp{object}.
\end{itemize}

The \cpp{object} type can contain values of the following types.

\begin{itemize}
  \item[\cpp{Nil}] This is the value \lisp{nil} which also happens to be the
    \cpp{nullptr} value of \cpp{lisp\_t}.
  \item[\cpp{Symbol}] A literal atom.
  \item[\cpp{Integer}] An integer number. This is a 64 bit integer.
  \item[\cpp{Float}] A double floating point number.
  \item[\cpp{Indirect}] Used in a closure.
  \item[\cpp{Cons}] A cons cell consisting of two \cpp{lisp\_t} values.
  \item[\cpp{String}] A string.
  \item[\cpp{Subr}] A compiled (\textsf{C++}) function. A compiled
    function may be spread or no spread and it may evaluate its
    arguments or not (fsubr). A compiled function may have zero to
    three arguments.
  \item[\cpp{Lambda}] A lambda function. As with a compiled function a
    lambda may be a spread or a no spread function and it may evaluate
    or not evaluates its arguments (nlambda).
  \item[\cpp{Closure}] A static binding.
  \item[\cpp{Environ}] Internal environment stack type.
  \item[\cpp{File}] A file object.
  \item[\cpp{Cvariable}] A \textsf{C++} variable which can be accessed
    and changed from both \textsf{C++} and from a lisp expression.
\end{itemize}

To check the type you can use the \cpp{type\_of} function which
returns a class enum of type \cpp{lisp::object::type}.

If you have a value of type \cpp{object} (always indirectly via a
\cpp{lisp\_t} pointer) you can get the actual value using various
getter functions and set the value with setter functions. There is no
type checking when in the getters so calling a getter with the wrong
type results in an exception.

\begin{itemize}
  \item \cpp{auto symbol() const -> symbol::ref\_symbol\_t} The literal atom.
  \item \cpp{auto value() const -> lisp\_t} Returns the value of a literal
    atom.
  \item \cpp{void value(lisp\_t)} Set the value of a literal atom.
  \item \cpp{auto intval() const -> std::int64\_t} Returns the 64 bit
    integer value.
  \item \cpp{auto floatval() const -> double} Returns the floating
    point value.
  \item \cpp{auto indirect() const -> lisp\_t} Returns the real
    value of the indirect value.
  \item \cpp{auto cons() const -> const cons\_t\&} Returns the cons
    cell.
  \item \cpp{auto car() const -> lisp\_t} Returns the \lisp{car} of
    the cons cell.
  \item \cpp{void car(lisp\_t)} Sets the \lisp{car} of the cons cell.
  \item \cpp{auto cdr() -> lisp\_t} Returns the \lisp{cdr} of
    the cons cell.
  \item \cpp{void cdr(lisp\_t)} Sets the \lisp{cdr} of the cons cell.
\end{itemize}

There are some literals which simplify creating lisp
objects. \cpp{operator""\_s} creates a string, \cpp{operator""\_a}
creates a literal atom, \cpp{operator""\_l} creates a number or a
floating point value depending on the argument type. Finally the
\cpp{operator""\_e} evaluates a string as a lisp expression and returns
the result of the evaluation.

\begin{lstlisting}[language=c++]
#include <lisp/lisp.hh>

int main()
{
  // Create the context.
  lisp::context ctx;
  // Create the lisp interpreter.
  lisp::vm vm(ctx);
  // The _l suffix creates a lisp object by parsing
  // the string.
  lisp::print(lisp::cons("a"_a, "b"_a)); // => (a . b)
}
\end{lstlisting}
\subsection{The REPL}
\cpp{lisp::repl} is an object which has an \cpp{lisp\_t
  operator()(lisp\_t)} which implements a simple read, eval, and print
loop.  The \cpp{lisp::vm} object has a member variable called
\cpp{repl} which is a function taking a \cpp{lisp\_t} type object and
returns a \cpp{lisp\_t} type object.

Typical usage.

\begin{lstlisting}[language=c++]
  lisp::context ctx;
  lisp::vm vm(ctx);
  lisp::repl repl(vm);
  lisp.repl = [&repl](lisp::lisp_t) -> lisp::lisp_t
  {
    return repl(lisp::NIL);
  };
  lisp.repl(lisp::NIL);
\end{lstlisting}

If the evaluation of an expression results in a break condition,
i.e. the evaluation cannot continue due to an error, then the
\cpp{lisp::vm::repl} function is called recursively. The
\cpp{lisp::repl} class recognizes some simple commands which allows
the state to be examined or evaluation to continue, possibly after
some changes to the environment or the program.

\subsection{Input/Output}
Input and output is handled with base classes called \cpp{source} and
\cpp{sink}. A \cpp{source} needs to implement the following pure
virtual functions.

\begin{description}
  \item[\cpp{int}] \cpp{getch()} \\ Read one character from the input source.
  \item[\cpp{void}] \cpp{ungetch(int)} \\ Put a character back on the input
    stream to be read next time \cpp{getch} is called.
  \item[\cpp{bool}] \cpp{close()} \\ Close the input source.
  \item[\cpp{std::optional<std::string>}] \cpp{getline()} \\ Read one line
    from the input source. Returns an empty optional at end of file.
  \item[\cpp{iterator}] \cpp{begin()} \\ Returns an iterator which when
    incremented reads the next character from the source.
\end{description}

A \cpp{sink} needs to override the following pure virtual functions.

\begin{description}
  \item[\cpp{void}] \cpp{putch(int, bool)} \\ Puts one character on
    the output stream. If the second bool parameter is \cpp{true} then
    characters are quoted with a backslash if non-printable.
  \item[\cpp{void}] \cpp{puts(const std::string\_view)} \\ Puts a
    string on the output stream.
  \item[\cpp{void}] \cpp{terpri()} \\ Prints a newline.
  \item[\cpp{void}] \cpp{flush()} \\ Flushes the sink.
  \item[\cpp{bool}] \cpp{close()} \\ Closes the sink.
\end{description}

Several sources and sinks are predefined.

\begin{description}
  \item[file\_source] The source is an existing file. The constructor
    takes a file name as its argument.
  \item[stream\_source] The stream source takes a \cpp{std::istream}
    as its argument.
  \item[string\_source] The string sources takes a \cpp{std::string}
    as its argument.
  \item[file\_sink] Takes a file name as its first argument. The
    second argument is a \cpp{bool} where \cpp{true} means append
    mode.
  \item[stream\_sink] Accepts a \cpp{std::ostream} as its argument.
  \item[string\_sink] Takes no argument. The data written to the
    string can be retrieved by calling the
    \cpp{string\_sink::string()} member function.
\end{description}

\subsection{Sharing Variables Between \lips\ and \textsf{C++}}
The type \cpp{cvariable\_t} is a class which enables sharing a
variable of type \cpp{lisp\_t} between lisp and \textsf{C++}.

\subsection{Adding New Primitives}
It's possible to create new primitive functions, functions which are
registered with the lisp interpreter and are callable a lisp
program. Registering a new primitive is done using the
\cpp{lisp::mkprim} function. \cpp{lisp::mkprim} takes four
arguments. The first is a string which is the literal atom to which
the function is bound. The second argument is a \textsf{C++} function
which takes a lisp interpreter and zero, one, two, or three
\cpp{lisp\_t} values and returns a \cpp{lisp\_t} value. It can be a lambda
function.  The third and fourth argument specifies if the function
should evaluate it's argument or not and if the function is a spread
or a no spread function.

Here is an example of defining a function called \lisp{printall} which
takes any number of arguments and prints them.

\begin{lstlisting}[language=c++]
  mkprim(
    "printall",
    [&result](lisp\_t a) -> lisp\_t {
      for(auto p: a)
      {
        print(p);
      }
      terpri();
      return NIL;
    },
    subr_t::subr::NOEVAL, subr_t::spread::NOSPREAD);
\end{lstlisting}

\section{Lisp Functions}
\label{functions}
This section describes functions available when programming in lisp.
Functions are shown in their lisp forms.  In \textsf{C++} the return
type of each function is \cpp{LISPT}.  Every function has an optional
first argument which is the lisp interpreter.  If left out the
currently active lisp interpreter is used.  For spread functions the
number of arguments of type \cpp{LISPT} are the same as their lisp
counterpart.  For nospread functions the \textsf{C++} function has
only one argument which should be a list.  There is no distinction
between lambda and nlambda functions in \textsf{C++} as the normal
\textsf{C++} evaluation rules apply.

\subsection{Arithmetic Functions}
\lips\ supports both integer and floating point numbers. There are
functions specific for either integers or floating points as well as
generic functions which can take either type.

\begin{defun}{Function}{(abs $n$)}
  The absolute value of $n$.
\end{defun}

\begin{defun}{Function}{(add1 $n$)}
  Add \lisp{1} to $n$ and return the value.
\end{defun}

\begin{defun}{Function}{(difference $x$ $y$)}
  Calculates the difference between $x$ and $y$.

  \example{(difference 8 3)}{5}
\end{defun}

\begin{defun}{Function}{(divide $x$ $y$)}
  Divides $x$ by $y$. The result may be an integer or a floating point
  depending on the types of $x$ and $y$. If both are integers the
  result will be an integer and if either $x$ or $y$, or both, is a
  floating point number the result will be a floating point number.
\end{defun}

\begin{defun}{Function}{(fdifference $x$ $y$)}
  Floating point difference between $x$ and $y$.
\end{defun}

\begin{defun}{Function}{(fdivide $x$ $y$)}
  Floating point division of $x$ by $y$.
\end{defun}

\begin{defun}{NoSpread Function}{(fplus \xargs)}
  Floating point addition of \largs
\end{defun}

\begin{defun}{NoSpread Function}{(ftimes \xargs)}
  Multiplies the floating point values \largs
\end{defun}

\begin{defun}{Function}{(idifference $x$ $y$)}
  Integer difference between $x$ and $y$.
\end{defun}

\begin{defun}{Function}{(iminus $x$)}
  Same as \lisp{(idifference 0 x)}.
\end{defun}

\begin{defun}{NoSpread Function}{(iplus \xargs)}
  Adds the values \largs
\end{defun}

\begin{defun}{Function}{(iquotient $x$ $y$)}
  The quotient of the integers $x$ and $y$.
\end{defun}

\begin{defun}{Function}{(iremainder $x$ $y$)}
  The integer remainder of $x$ and $y$.
\end{defun}

\begin{defun}{NoSpread Function}{(itimes \xargs)}
  Multiplies the integer values \largs
\end{defun}

\begin{defun}{Function}{(itof $x$)}
  Convert an integer $x$ to a value of floating point type.
\end{defun}

\begin{defun}{Function}{(minus $x$)}
  Returns the equivalent of \lisp{(difference 0 x)}.
\end{defun}

\begin{defun}{Function}{(minusp $x$)}
  Returns \T\ if $x$ is less than zero, \NIL\ otherwise.
\end{defun}

\begin{defun}{Function}{(numberp $x$)}
  Returns $x$ if $x$ is either an integer or a floating point number,
  \NIL\ otherwise.
\end{defun}

\begin{defun}{NoSpread Function}{(plus \xargs)}
  Sum up the values \largs
\end{defun}

\begin{defun}{Function}{(sub1 $x$)}
  Returns \lisp{(plus x 1)}.
\end{defun}

\begin{defun}{NoSpread Function}{(times \xargs)}
  Multiplies the numbers \largs
\end{defun}

\subsection{Variables}
Functions for setting the value cell of an atom.

\begin{defun}{Function}{(set $a$ $e$)}
  Sets the value cell of $a$ to the value of the expression $e$.
\end{defun}

\begin{defun}{NLambda Function}{(setq $a$ $e$)}
  Same as \lisp{set} but doesn't evaluate the first argument $a$.
\end{defun}

\begin{defun}{NLambda Function}{(setqq $a$ $e$)}
  Same as \lisp{set} but neither $a$ nor $e$ are evaluated.
\end{defun}

\subsection{Logic Functions}
All logic functions return \NIL if the function evaluates to false and
non-\NIL otherwise.

\begin{defun}{NoSpread NLambda Function}{(and \xargs)}
  Evaluates each argument \largs\ in sequence and returns the value of
  the last expression if all arguments evaluates to non-\NIL. As soon
  as an argument which evaluates to \NIL\ is encountered, \NIL\ is
  returned. Thus the function short circuits the arguments.
\end{defun}

\begin{defun}{Function}{(not $x$)}
  Returns \NIL\ if $x$ is non-\NIL\ and \T\ otherwise.
\end{defun}


\begin{defun}{NLambda Function}{(or \xargs)}
  Evaluates each argument \largs\ in sequence and returns \NIL\ if all
  arguments evaluates to \NIL. As soon as an argument is evaluated to
  a non-\NIL\ value that value is returned.
\end{defun}

\subsection{String Functions}

\begin{defun}{Function}{(concat \xargs)}
  Concatenate the strings \largs Strings are copied.
\end{defun}

\begin{defun}{Function}{(strcmp $s_{1}$ $s_{2}$)}
  Compares the two strings $s_{1}$ and $s_{2}$ lexicographically and
  returns a negative number, zero, or a positive number if $s_{1}$ is
  less than, equal, or greater than $s_{2}$.
\end{defun}

\begin{defun}{Function}{(strequal $s_{1}$ $s_{2}$)}
  Compares the strings $s_{1}$ and $s_{2}$ and returns \T\ if the
  strings are equal or \NIL\ if they are not equal.
\end{defun}

\begin{defun}{Function}{(stringp $s$)}
  Returns \T\ if $s$ is a string, \NIL\ otherwise.
\end{defun}

\begin{defun}{Function}{(strlen $s$)}
  Returns the length of the string $s$.
\end{defun}

\begin{defun}{Function}{(substring $x$ $n$ $m$)}
  Creates a new string which is a substring of $x$ starting from the
  $n$th character through the $m$th character. If $m$ is \NIL\ the
  substring starts from the $n$th character through to the end.

  Negative numbers are treated as the $n$th or $m$th character from
  the end.

  \begin{examples}
    \ex{(substring "hello" 2 3)}{"el"}
    \ex{(substring "hello" 2 1)}{nil}
    \ex{(substring "hello" 2 -2)}{"ell"}
    \ex{(substring "hello" -3 -1)}{"llo"}
    \ex{(substring "hello" -1 -3)}{nil}
  \end{examples}

\end{defun}


\begin{defun}{Function}{(symstr $a$)}
  Returns a symbol's print string.
\end{defun}

\subsection{List Functions}

\begin{defun}{Function}{(append \xargs)}
  Append all the arguments, i.e. x$_{2}$ is appended to x$_{1}$,
  x$_{3}$ to x$_{2}$, and so on. All arguments must be lists. Any
  argument which is \NIL\ is ignored. All lists are copied which means
  that \lisp{(append x)} makes a copy of $x$. All arguments have to be
  lists.

  \example{(append '(a b) '(c d) '(e f))}{(a b c d e f)}
\end{defun}

\begin{defun}{Function}{(attach $x$ $y$)}
  Destructive version of \lisp{cons} which prepends $x$ to $y$ and any
  reference to $y$ will contain the modified list.
\end{defun}

\begin{defun}{Function}{(car $x$)}
  Returns the value stored in the head of the cons cell. If $x$ is
  \NIL\ it returns \NIL.
\end{defun}

\begin{defun}{Function}{(cdr $x$)}
  Returns the value stored in the tail of the cons cell. If $x$ is
  \NIL\ it returns \NIL.
\end{defun}


\begin{defun}{Function}{(caaar $x$)}
  \lisp{(car (car (car x)))}
\end{defun}

\begin{defun}{Function}{(caadr $x$)}
  \lisp{(car (car (cdr x)))}
\end{defun}

\begin{defun}{Function}{(caar $x$)}
  \lisp{(car (car x))}
\end{defun}

\begin{defun}{Function}{(cadar $x$)}
  \lisp{(car (cdr (car x)))}
\end{defun}

\begin{defun}{Function}{(caddr $x$)}
  \lisp{(car (cdr (cdr x)))}
\end{defun}

\begin{defun}{Function}{(cadr $x$)}
  \lisp{(car (cdr x))}
\end{defun}

\begin{defun}{Function}{(cdaar $x$)}
  \lisp{(cdr (car (car x)))}
\end{defun}

\begin{defun}{Function}{(cdadr $x$)}
  \lisp{(cdr (car (cdr x)))}
\end{defun}

\begin{defun}{Function}{(cdar $x$)}
  \lisp{(cdr (car x))}
\end{defun}

\begin{defun}{Function}{(cddar $x$)}
  \lisp{(cdr (cdr (car x)))}
\end{defun}

\begin{defun}{Function}{(cdddr $x$)}
  \lisp{(cdr (cdr (cdr x)))}
\end{defun}

\begin{defun}{Function}{(cddr $x$)}
  \lisp{(cdr (cdr x))}
\end{defun}

\begin{defun}{Function}{(cons $a$ b)}
  Create a \lisp{cons} cell and populate the head and the tail with
  the values $a$ and $b$. If $b$ is left out the tail will be \NIL. If
  both $a$ and $b$ are left out then both the head and the tail will
  be \NIL.

  \begin{examples}
    \ex{(cons 'a 'b)}{(a .\ b)}
    \ex{(const 'a '(b))}{(a b)}
    \ex{(cons)}{(nil)}
  \end{examples}
\end{defun}

\begin{defun}{Function}{(length $l$)}
  Returns the length of the list $l$.
\end{defun}

\begin{defun}{Function}{(list \xargs)}
  Create a list of the items \largs
\end{defun}

\begin{defun}{Function}{(nconc \xargs)}
  Same as \lisp{append} but modifies the arguments \largs
\end{defun}

\begin{defun}{Function}{(nth $x$ $n$)}
  Returns the $n$th tail of $x$. Returns \NIL\ if there are fewer
  elements in $x$ than $n$.

  \begin{examples}
    \ex{(nth '(a b c) 2)}{(b c)}
    \ex{(nth '(a b c) 4)}{nil}
  \end{examples}
\end{defun}

\begin{defun}{Function}{(memb $x$ $y$)}
  Looks for an element $x$ in $y$ using \lisp{eq}, returning the tail
  with that element at the head. Returns \NIL\ if not found.

  \begin{examples}
    \ex{(memb 'a '(a b c))}{(a b c)}
    \ex{(memb 'b '(a b c))}{(b c)}
    \ex{(memb 'd '(a b c))}{nil}
  \end{examples}

\end{defun}


\begin{defun}{Function}{(rplaca $x$ $y$)}
  Replaces \lisp{car} of $x$ with $y$ destructively.
\end{defun}

\begin{defun}{Function}{(rplacd $x$ $y$)}
  Replaces \lisp{cdr} of $x$ with $y$ destructively.
\end{defun}

\begin{defun}{Function}{(tconc $l$ $o$)}
  The \lisp{car} of $l$ is a list and the \lisp{cdr} of $l$ is a
  pointer to the first element of the list.  The object $o$ is added
  to the end of the list and the \lisp{cdr} is updated.  An empty $l$
  should be \lisp{(nil}) but if $l$ is \NIL\ it is initialized to
  \lisp{((o) o)}.  All pointers to $l$ points to the new list since
  the changes are destructive.
\end{defun}

\subsection{Functions to Function and Evaluate Functions}

\begin{defun}{Function}{(apply $fn$ $l$)}
  Applies the function $fn$ to the arguments in the list $l$ as if
  $fn$ is called with the list as its arguments.

  \example{(apply car '((a b c)))}{a}
\end{defun}

\begin{defun}{NoSpread Function}{(apply* fn \xargs)}
  A nospread version of \lisp{apply}.

  \example{(apply* car '(a b c))}{a}
\end{defun}

\begin{defun}{Function}{(closure $f$ $v$)}
  \label{closure}
  Eval function that forms the closure of function $f$, with variables
  listed in $v$ statically bound.  This is close to function in other
  lisp dialects. Any closure that is created within another closure
  and lists a variable contained in that closure refers to the same
  variable. This makes it possible for two closures to share one or
  more variables.

  Here is an example of defining a simple function which maintains the
  balance of a bank account.

  \begin{lstlisting}[numbers=left,numberstyle=\tiny]
(defineq
  (make-account
   (lambda (balance)
     ((closure
          '(progn
            (setq withdraw
             (closure
                 (lambda (amount)
                   (setq balance (difference balance amount)))
                 '(balance)))
            (setq deposit
             (closure
                 (lambda (amount)
                   (setq balance (plus balance amount)))
                 '(balance)))
            (lambda ()
              (closure
                  (lambda (m)
                    (cond
                      ((eq m 'withdraw) withdraw)
                      ((eq m 'deposit) deposit)
                      (t nil)))
                  '(withdraw deposit))))
          '(balance withdraw deposit))))))
  \end{lstlisting}

  The function \lisp{make-account} creates and returns a closure
  object which binds the three symbols on line 24 in their lexical
  scope. It sets the symbols \lisp{withdraw} and \lisp{deposit} each
  to a closure over \lisp{balance} with a lambda expression which
  subtracts or adds an \lisp{amount} to the \lisp{balance}.
\end{defun}


\begin{defun}{Function}{(define $x$)}
  Functions functions according to $x$. Each element of the list $x$
  is a list of the form \lisp{(name args .\ body)}. The list is
  evaluated.
\end{defun}

\begin{defun}{NLambda NoSpread Function}{(defineq $x$ $\cdots$)}
  Functions functions according to the list $x$. Each element of the
  list $x$ is of the form \lisp{(name def)} where name is the name of
  the function and the def is a lambda expression.

  \example{(defineq (double (lambda (x) (times 2 x))))}{(double)}
\end{defun}

\begin{defun}{Function}{(eval $e$)}
  Evaluate the expression $e$.
\end{defun}

\begin{defun}{Function}{(evaltrace $n$)}
  Sets the trace variable to $n$. If $n$ is greater than zero the
  interpreter will print some more details on how expressions are
  evaluated. Call \lisp{evaltrace} with a zero argument to turn off
  the tracing.
\end{defun}

\begin{defun}{NLambda Function}{(e $x$)}
  Nlambda version of \lisp{eval}. Evaluates $x$. To illustrate the
  difference between the functions \lisp{eval} and \lisp{e}:

  \begin{examples}
    \ex{(setq f '(plus 1 2))}{(plus 1 2)}
    \ex{(e f)}{(plus 1 2)}
    \ex{(eval f)}{3}
  \end{examples}

\end{defun}

\begin{defun}{Function}{(getrep $x$)}
  Returns the function definition of a \lisp{lambda} or a
  \lisp{nlambda} function object. Calling \lisp{getrep} on any other
  type of object (including \lisp{subr} and \lisp{fsubr}) returns
  \NIL.

  \begin{examples}
    \ex{(defineq (double (lambda (x) (times 2 x))))}{(double)}
    \ex{(getrep double)}{(lambda (x) (times 2 x))}
    \ex{double}{\#<lambda 7fec0a810ce0>}
    \ex{(getrep apply)}{nil}
  \end{examples}

\end{defun}


\begin{defun}{Function}{(lambda $x$ .\ $y$)}
  Creates a lambda object. The parameter $x$ is the parameters of the
  function being defined. If it's a list of atoms the function is a
  spread function, if it's a single atoms the function is a nospread
  function, if it's dotted pair the function is a half spread
  function.

  A ``spread'' function binds each formal parameter to the actual
  parameters when the function is called. Any excess parameter is
  ignored and any missing actual parameter is bound to \NIL.

  A ``nospread'' function binds the formal parameter to a list of all
  actual parameters when called.

  A ``half spread'' function is a combination of the above where the
  actual parameters are bound to each formal parameter and any excess
  actual parameters are bound to the formal parameter in the
  symbol in the \lisp{cdr} of the list of formal parameters.
\end{defun}

\begin{defun}{Function}{(nlambda $x$ .\ $y$)}
  Same as \lisp{lambda} except that the function object is an nlambda
  function object and parameters are not evaluated when the function
  is called.
\end{defun}

\begin{defun}{Function}{(prog1 \xargs)}
  Evaluate each expression in sequence, returning the result of the
  first expression.
\end{defun}

\begin{defun}{Function}{(progn \xargs)}
  Similar to \lisp{prog1} but instead the value of the last expression
  is returned.
\end{defun}


\begin{defun}{NLambda Function}{(quote $x$)}
  Returns $x$ unevaluated.
\end{defun}

\subsection{Predicates}

\begin{defun}{Function}{(atom $x$)}
  Predicate which is true if $x$ is an atom, either a symbol or a
  number. Strings, for example, are not atoms.
\end{defun}

\begin{defun}{Function}{(boundp $x$)}
  Evaluates to \T\ if $x$ is not bound to a value. Note that the
  argument $x$ is evaluated.

  \example{(boundp 'x)}{\T}

  if x is not bound to a value.
\end{defun}

\begin{defun}{Function}{(eq $x$ $y$)}
  Returns \T\ if $x$ is the same object as $y$.
\end{defun}

\begin{defun}{Function}{(eqp $x$ $y$)}
  If both $x$ and $y$ are numbers then \lisp{eqp} returns \T\ if the
  numbers are the same, otherwise return the \lisp{(eq $x$ $y$)}.
\end{defun}

\begin{defun}{Function}{(equal $x$ $y$)}
  Return \T\ if $x$ and $y$ are \lisp{eq}, or if $x$ and $y$ are
  \lisp{eqp}, or if $x$ and $y$ are \lisp{strequal}, or if $x$ and $y$
  are lists \lisp{(and (equal (car $x$) (car $x$)) (equal (cdr $x$)
    (cdr $y$)))}.
\end{defun}

\begin{defun}{Function}{(geq $x$ $y$)}
  \T\ if $x \ge y$, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(greaterp $x$ $y$)}
  \T\ if $x > y$, otherwise \NIL.
\end{defun}


\begin{defun}{Function}{(leq $x$ $y$)}
  \T\ if $x \le y$, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(lessp $x$ $y$)}
  \T\ if $x < y$, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(listp $x$)}
  \T\ if $x$ is a list, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(litatom $x$)}
  \T\ if $x$ is a literal atom, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(neq $x$ $y$)}
  \T\ if $x$ is not \lisp{eq} to $y$, otherwise \NIL. Equivalent to
  \lisp{(not (eq $x$ $y$))}.
\end{defun}

\begin{defun}{Function}{(neqp $x$ $y$)}
  \T\ if $x$ is not \lisp{eqp} to $y$, otherwise \NIL. Equivalent to
  \lisp{(not (eqp $x$ $y$))}.
\end{defun}

\begin{defun}{Function}{(nlistp $x$)}
  \T\ if $x$ is not a list, otherwise \NIL. Same as \lisp{(not (listp
    $x$))}.
\end{defun}

\begin{defun}{Function}{(null $x$)}
  \T\ if $x$ is \NIL, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(symbolp $x$)}
  Same as \lisp{(litatom $x$)}.
\end{defun}

\begin{defun}{Function}{(zerop $x$)}
  \T\ if $x$ is zero, otherwise \NIL.
\end{defun}

\subsection{Property List Functions}
\lips\ supports property lists on literal atoms. A property list is a
list of values stored in the ``property cell'' of a literal atom. A
property list is list of alternating properties and values. For
example the property list \lisp{(a 1 b 2)} has two properties \lisp{a}
and \lisp{b} with the values \lisp{1} and \lisp{2}
respectively. \lisp{eq} is used to compare properties when
manipulating the property list with the below functions.

\begin{defun}{Function}{(getplist $a$)}
  Returns the entire property list stored in the property cell of $a$.
\end{defun}


\begin{defun}{Function}{(getprop $a$ $p$)}
  Returns the value of property $p$ stored in the property cell of the
  literal atom $a$.
\end{defun}

\begin{defun}{Function}{(putprop $a$ $p$ $v$)}
  Puts the value $v$ in the property $p$ of $a$.
\end{defun}

\begin{defun}{Function}{(remprop $a$ $p$)}
  Removes the property $p$ from the literal atom $a$.
\end{defun}

\begin{defun}{Function}{(setplist $a$ $pl$)}
  Sets the property list of $a$ to $pl$.
\end{defun}

\subsection{Input and Output Functions}
All output functions taking a file descriptor $f$ as a parameter
operates on the primary output if $f$ is \NIL, or on primary error if
$f$ is \T, otherwise $f$ must be a file handle open for writing.

For input functions the file descriptor $f$ is instead primary input
if $f$ is \NIL, stdin if $f$ is \T, or a file handle of a file open
for reading.

\begin{defun}{Function}{(close $f$)}
  Closes the file associated with f.
\end{defun}

\begin{defun}{Function}{(load $fn$)}
  Loads a file, evaluating each s-expression.
\end{defun}

\begin{defun}{Function}{(open $fn$)}
  Open a file.
\end{defun}

\begin{defun}{Function}{(print)}
  Print in such a way that whatever is printed can be read back by the
  interpreter. This means including double quotes around strings and
  quoting special characters with backslashes.
\end{defun}


\begin{defun}{Function}{(prin1 $x$ $f$)}
  Prints the arguments without escapes, i.e. strings are printed
  without surrounding double quotes, and without a terminating
  newline.
\end{defun}

\begin{defun}{Function}{(prin2 \xargs)}
  Same as \lisp{print} but without a terminating newline.
\end{defun}

\begin{defun}{Function}{(printlevel)}
  Specifies how deep printing should go.
\end{defun}

\begin{defun}{Function}{(ratom $f$)}
  Read an atom from $f$.
\end{defun}

\begin{defun}{Function}{(read $f$)}
  Read an S-expression from $f$.
\end{defun}

\begin{defun}{Function}{(readc $f$)}
  Read one character from $f$.
\end{defun}

\begin{defun}{Function}{(readline $f$)}
  Read a line up to a newline from $f$.
\end{defun}

\begin{defun}{Function}{(spaces $n$ $f$)}
  Print $n$ spaces to $f$.
\end{defun}

\begin{defun}{Function}{(terpri $f$)}
  Print a newline to $f$.
\end{defun}

\subsection{Conditionals and Control Functions}

\begin{defun}{Function}{(cond (p$_{1}$ e$_{1}$ $\cdots$) (p$_{2}$ e$_{2}$ $\cdots$)
    $\cdots$)} The predicates p$_{n}$ are evaluated in order
  and the first that is evaluated to anything other than \NIL, the
  expressions after that predicate is evaluated.  The last expression
  evaluated is returned as in progn.  If no predicate evaluates to
  non-\NIL, \NIL\ is returned.
\end{defun}


\begin{defun}{NLambda Function}{(if $p$ $t$ . $f$)}
  If the predicate $p$ evaluates to a non-\NIL\ value the expression
  $t$ is evaluated and returned from the function. If $p$ evaluates to
  \NIL\ then the value of the expression $f$ is returned.
\end{defun}

\begin{defun}{NLambda Function}{(while $p$ \xargs)}
  While the predicate $p$ evaluates to a non-\NIL\ value the sequence
  of expressions \largs are evaluated in sequence. \lisp{while} always
  returns \NIL.
\end{defun}

\subsection{Map Functions}
Map functions iterate over a list of items and applies a function to
either each item or each tail of the list.

\begin{defun}{Function}{(map $list$ $fn_{1}$ $fn_{2}$)}
  If $fn_{2}$ is \NIL, apply the function $fn_{1}$ on each tail of
  $list$. First $fn_{1}$ is applied to $list$, then \lisp{(cdr list)},
  and so on. If $fn_{2}$ is not \NIL\ then $fn_{2}$ is called instead
  of \lisp{cdr} to get the next value on which to apply $fn_{1}$.
  \lisp{map} returns \NIL.

  \begin{quote}
    \lisp{$\leftarrow$(map '(a b c) (lambda (l) (print l)))}\\
    \lisp{(a b c)}\\
    \lisp{(b c)}\\
    \lisp{(c)}\\
    \NIL
  \end{quote}

\end{defun}

\begin{defun}{Function}{(mapc $list$ $fn_{1}$ $fn_{2}$)}
  \lisp{mapc} is the same as \lisp{map} except that $fn_{1}$ is
  applied to \lisp{(car list)} instead of the list. Effectively
  applying $fn_{1}$ on each element of the list. \lisp{mapc} returns
  \NIL.
\end{defun}


\begin{defun}{Function}{(maplist $list$ $fn_{1}$ $fn_{2}$)}
  The same as \lisp{map} but collects the results from applying
  $fn_{1}$ on each tail and returning a list of the results.

  \example{(maplist '(a b c) (lambda (l) (length l)))}{(3 2 1)}
\end{defun}

\begin{defun}{Function}{(mapcar $list$ $fn_{1}$ $fn_{2}$)}
  Equivalent to \lisp{mapc} but collects the results in a list like
  \lisp{maplist}.

  \example{(mapcar '(1 2 3) (lambda (n) (plus n 1)))}{(2 3 4)}
\end{defun}

\subsection{Special Functions}

\begin{defun}{Function}{(backtrace)}
  Prints a backtrace of the evaluation stack when called.
\end{defun}

\begin{defun}{Function}{(exit $code$)}
  Throws the exception \cpp{lisp::lisp\_finish} which contains the
  member variable \cpp{exit\_code}.  This member variable is set to
  the value of $code$. The main function of the C++ program should
  catch this exception and call \cpp{exit(ex.exit\_code)}.
\end{defun}

\begin{defun}{Function}{(freecount)}
  Returns the number of free cons cells available. Since
  \lips\ doesn't manage memory with garbage collection this value is
  rather useless.
\end{defun}

\begin{defun}{Function}{(topofstack)}
  Returns the current environment.
\end{defun}

\begin{defun}{Function}{(destblock $e$)}
  Returns the destination block from an environment. Here is an
  example showing the destination block in some cases.
  \begin{examples}
    \ex{(setq a 88)}{88}
    \ex{(defineq\\
      \hspace*{3mm}(f0 (lambda (a) (destblock (topofstack))))\\
      \hspace*{3mm}(f1 (lambda (a) (f0 a))))}{(f0 f1)}
    \ex{(f1 99)}{(1 (a . 99))}
    \ex{(f0 101)}{(1 (a . 88))}
  \end{examples}
\end{defun}


\begin{defun}{Function}{(typeof $x$)}
  Returns a literal atom describing the data type of $x$.

  \begin{examples}
    \ex{(typeof 'a)}{symbol}
    \ex{(typeof 100)}{integer}
    \ex{(typeof nil)}{nil}
    \ex{(typeof t)}{t}
    \ex{(typeof 1.0)}{float}
    \ex{(typeof "string")}{string}
  \end{examples}

\end{defun}

\begin{defun}{Function}{(obarray)}
  Returns a list of all literal atoms
  currently active in the system.
\end{defun}

\subsection{Shell Functions}
This section describes functions which implement shell features like
output redirection, changing the working directory, job control, etc.

All functions that in some way redirects its input or output are
executed in a fork.  This means that redirecting I/O of a lisp
function doesn't make permanent changes to the \lips\ environment.  No
global variables are changed.

All functions in this section are nlambda functions.

\begin{defun}{NLambda Function}{(cd $d$)}
  Changes current working directory to $d$.
\end{defun}


\begin{defun}{NLambda Function}{(redir-to $cmd$ $file$ $fd$)}
  Evaluates the expression $cmd$, redirecting the output from this
  expression to a file with the file name $file$. The third parameter
  $fd$ is optional and if given should be the file descriptor to
  redirect. The default is to redirect stdout.
\end{defun}

\begin{defun}{NLambda Function}{(redir-from $cmd$ $file$ $fd$)}
  Evaluates the expression $cmd$, redirecting the file descriptor $fd$
  (or stdin if not given) from the file $file$.
\end{defun}

\begin{defun}{NLambda Function}{(append-to $cmd$ $file$ $fd$)}
  Same as \lisp{redir-to} but append to the file $file$ instead of
  overwriting it.
\end{defun}

\begin{defun}{NLambda Function}{(pipe-cmd \xargs)}
  Connects the stdout of $x_{1}$ to stdin of $x_{2}$ and stdout of
  $x_{2}$ to stdin of $x_{3}$ and so on. If there is only one
  expression it is simply evaluated.
\end{defun}

\begin{defun}{NLambda Function}{(back $cmd$)}
  Creates a new process and evaluates the command $cmd$ in this
  process. A new job is created which can be controlled by the job
  controlling functions.
\end{defun}

\begin{defun}{NLambda Function}{(stop)}
  Sends a stop signal to itself.
\end{defun}

\begin{defun}{NLambda Function}{(rehash)}
  \lips\ keeps a hash of all executable files in the \lisp{path} so
  that it can fail fast if a program is not available. The
  \lisp{rehash} function rebuilds this hash in order to pick up new
  programs.
\end{defun}

\begin{defun}{NLambda Function}{(jobs)}
  Lists all jobs currently in flight.
\end{defun}

\begin{defun}{NLambda Function}{(fg $job$)}
  Brings the job $job$ running
  in the background to the foreground.
\end{defun}

\begin{defun}{NLambda Function}{(bg $job$)}
  Continues the job $job$ in the background.
\end{defun}

\begin{defun}{NLambda Function}{(setenv $var$ $val$)}
  Sets the environment variable $var$ to the value $val$.
\end{defun}

\begin{defun}{NLambda Function}{(getenv $var$)}
  Returns the value of the environment varable $var$ or \NIL\ if the
  variable is not set.
\end{defun}

\begin{defun}{NLambda Function}{(exec $cmd$)}
  Replaces the current process with $cmd$.
\end{defun}

\section{Using \lips\ as a Library}

This section describes using \lips\ as a library. Most functions which
are available in lisp are also available in \textsf{C++}.

\section{Properties}
This section describes some properties that are used internally by the
shell.

\begin{description}
\item[alias] this is used during alias expansion.  Let's say we want
  to define an alias for ls that uses the -F option of ls: \lisp{(putprop 'l
  'alias '(ls -F))}.  To simplify defining aliases the lisp function
  alias is provided (see below).
\item[autoload] If during evaluation of a form, an undefined function
  is found the offending atom may have a file stored under this
  property. If this is the case the file is loaded and evaluation is
  allowed to continue.  If the function is still undefined error
  processing takes over.
\end{description}

\end{document}
