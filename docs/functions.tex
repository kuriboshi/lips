%
% Copyright 2022 Krister Joas
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%     http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%
\section{Lisp Functions}
\label{functions}
This section describes functions available when programming in lisp.
Functions are shown in their lisp forms.  In \textsf{C++} the return
type of each function is \cpp{LISPT}.  Every function has an optional
first argument which is the lisp interpreter.  If left out the
currently active lisp interpreter is used.  For spread functions the
number of arguments of type \cpp{LISPT} are the same as their lisp
counterpart.  For nospread functions the \textsf{C++} function has
only one argument which should be a list.  There is no distinction
between lambda and nlambda functions in \textsf{C++} as the normal
\textsf{C++} evaluation rules apply.

\subsection{Arithmetic Functions}
\lips\ supports both integer and floating point numbers. There are
functions specific for either integers or floating points as well as
generic functions which can take either type.

\begin{defun}{Function}{(abs $n$)}
  The absolute value of $n$.
\end{defun}

\begin{defun}{Function}{(add1 $n$)}
  Add \lisp{1} to $n$ and return the value.
\end{defun}

\begin{defun}{Function}{(difference $x$ $y$)}
  Calculates the difference between $x$ and $y$.

  \example{(difference 8 3)}{5}
\end{defun}

\begin{defun}{Function}{(divide $x$ $y$)}
  Divides $x$ by $y$. The result may be an integer or a floating point
  depending on the types of $x$ and $y$. If both are integers the
  result will be integers and if either $x$ or $y$ is a floating point
  number the result will be a floating point number.
\end{defun}

\begin{defun}{Function}{(fdifference $x$ $y$)}
  Floating point difference between $x$ and $y$.
\end{defun}

\begin{defun}{Function}{(fdivide $x$ $y$)}
  Floating point division of $x$ by $y$.
\end{defun}

\begin{defun}{NoSpread Function}{(fplus \xargs)}
  Floating point addition of \largs
\end{defun}

\begin{defun}{NoSpread Function}{(ftimes \xargs)}
  Multiplies the floating point values \largs
\end{defun}

\begin{defun}{Function}{(idifference $x$ $y$)}
  Integer difference between $x$ and $y$.
\end{defun}

\begin{defun}{Function}{(iminus $x$)}
  Same as \lisp{(idifference 0 x)}.
\end{defun}

\begin{defun}{NoSpread Function}{(iplus \xargs)}
  Adds the values \largs
\end{defun}

\begin{defun}{Function}{(iquotient $x$ $y$)}
  The quotient of the integers $x$ and $y$.
\end{defun}

\begin{defun}{Function}{(iremainder $x$ $y$)}
  The integer remainder of $x$ and $y$.
\end{defun}

\begin{defun}{NoSpread Function}{(itimes \xargs)}
  Multiplies the integer values \largs
\end{defun}

\begin{defun}{Function}{(itof $x$)}
  Convert an integer $x$ to a value of floating point type.
\end{defun}

\begin{defun}{Function}{(minus $x$)}
  Returns the equivalent of \lisp{(difference 0 x)}.
\end{defun}

\begin{defun}{Function}{(minusp $x$)}
  Returns \T\ if $x$ is less than zero, \NIL\ otherwise.
\end{defun}

\begin{defun}{Function}{(numberp $x$)}
  Returns $x$ if $x$ is either an integer or a floating point number,
  \NIL\ otherwise.
\end{defun}

\begin{defun}{NoSpread Function}{(plus \xargs)}
  Sum up the values \largs
\end{defun}

\begin{defun}{Function}{(sub1 $x$)}
  Returns \lisp{(plus x 1)}.
\end{defun}

\begin{defun}{NoSpread Function}{(times \xargs)}
  Multiplies the numbers \largs
\end{defun}

\subsection{Variables}
Functions for setting the value cell of an atom.

\begin{defun}{Function}{(set $a$ $e$)}
  Sets the value cell of $a$ to the value of the expression $e$.
\end{defun}

\begin{defun}{NLambda Function}{(setq $a$ $e$)}
  Same as \lisp{set} but doesn't evaluate the first argument $a$.
\end{defun}

\begin{defun}{NLambda Function}{(setqq $a$ $e$)}
  Same as \lisp{set} but neither $a$ nor $e$ are evaluated.
\end{defun}

\subsection{Logic Functions}
All logic functions return \NIL if the function evaluates to false and
non-\NIL otherwise.

\begin{defun}{NoSpread NLambda Function}{(and \xargs)}
  Evaluates each argument \largs\ in sequence and returns the value of
  the last expression if all arguments evaluates to non-\NIL. As soon
  as an argument which evaluates to \NIL\ is encountered, \NIL\ is
  returned. Thus the function short circuits the arguments.
\end{defun}

\begin{defun}{Function}{(not $x$)}
  Returns \NIL\ if $x$ is non-\NIL\ and \T\ otherwise.
\end{defun}


\begin{defun}{NLambda Function}{(or \xargs)}
  Evaluates each argument \largs\ in sequence and returns \NIL\ if all
  arguments evaluates to \NIL. As soon as an argument is evaluated to
  a non-\NIL\ value that value is returned.
\end{defun}

\subsection{String Functions}

\begin{defun}{Function}{(concat \xargs)}
  Concatenate the strings \largs Strings are copied.
\end{defun}

\begin{defun}{Function}{(strcmp $s_{1}$ $s_{2}$)}
  Compares the two strings $s_{1}$ and $s_{2}$ lexicographically and
  returns a negative number, zero, or a positive number if $s_{1}$ is
  less than, equal, or greater than $s_{2}$.
\end{defun}

\begin{defun}{Function}{(strequal $s_{1}$ $s_{2}$)}
  Compares the strings $s_{1}$ and $s_{2}$ and returns \T\ if the
  strings are equal or \NIL\ if they are not equal.
\end{defun}

\begin{defun}{Function}{(stringp $s$)}
  Returns \T\ if $s$ is a string, \NIL\ otherwise.
\end{defun}

\begin{defun}{Function}{(strlen $s$)}
  Returns the length of the string $s$.
\end{defun}

\begin{defun}{Function}{(substring $x$ $n$ $m$)}
  Creates a new string which is a substring of $x$ starting from the
  $n$th character through the $m$th character. If $m$ is \NIL\ the
  substring starts from the $n$th character through to the end.

  Negative numbers are treated as the $n$th or $m$th character from
  the end.

  \begin{examples}
    \ex{(substring "hello" 2 3)}{"el"}
    \ex{(substring "hello" 2 1)}{nil}
    \ex{(substring "hello" 2 -2)}{"ell"}
    \ex{(substring "hello" -3 -1)}{"llo"}
    \ex{(substring "hello" -1 -3)}{nil}
  \end{examples}

\end{defun}


\begin{defun}{Function}{(symstr $a$)}
  Returns a symbol's print string.
\end{defun}

\subsection{List Functions}

\begin{defun}{Function}{(append \xargs)}
  Append all the arguments, i.e. x$_{2}$ is appended to x$_{1}$,
  x$_{3}$ to x$_{2}$, and so on. All arguments must be lists. Any
  argument which is \NIL\ is ignored. All lists are copied which means
  that \lisp{(append x)} makes a copy of $x$. All arguments have to be
  lists.

  \example{(append '(a b) '(c d) '(e f))}{(a b c d e f)}
\end{defun}

\begin{defun}{Function}{(attach $x$ $y$)}
  Destructive version of \lisp{cons} which prepends $x$ to $y$ and any
  reference to $y$ will contain the modified list.
\end{defun}

\begin{defun}{Function}{(car $x$)}
  Returns the value stored in the head of the cons cell. If $x$ is
  \NIL\ it returns \NIL.
\end{defun}

\begin{defun}{Function}{(cdr $x$)}
  Returns the value stored in the tail of the cons cell. If $x$ is
  \NIL\ it returns \NIL.
\end{defun}


\begin{defun}{Function}{(caaar $x$)}
  \lisp{(car (car (car x)))}
\end{defun}

\begin{defun}{Function}{(caadr $x$)}
  \lisp{(car (car (cdr x)))}
\end{defun}

\begin{defun}{Function}{(caar $x$)}
  \lisp{(car (car x))}
\end{defun}

\begin{defun}{Function}{(cadar $x$)}
  \lisp{(car (cdr (car x)))}
\end{defun}

\begin{defun}{Function}{(caddr $x$)}
  \lisp{(car (cdr (cdr x)))}
\end{defun}

\begin{defun}{Function}{(cadr $x$)}
  \lisp{(car (cdr x))}
\end{defun}

\begin{defun}{Function}{(cdaar $x$)}
  \lisp{(cdr (car (car x)))}
\end{defun}

\begin{defun}{Function}{(cdadr $x$)}
  \lisp{(cdr (car (cdr x)))}
\end{defun}

\begin{defun}{Function}{(cdar $x$)}
  \lisp{(cdr (car x))}
\end{defun}

\begin{defun}{Function}{(cddar $x$)}
  \lisp{(cdr (cdr (car x)))}
\end{defun}

\begin{defun}{Function}{(cdddr $x$)}
  \lisp{(cdr (cdr (cdr x)))}
\end{defun}

\begin{defun}{Function}{(cddr $x$)}
  \lisp{(cdr (cdr x))}
\end{defun}

\begin{defun}{Function}{(cons $a$ b)}
  Create a \lisp{cons} cell and populate the head and the tail with
  the values $a$ and $b$. If $b$ is left out the tail will be \NIL. If
  both $a$ and $b$ are left out then both the head and the tail will
  be \NIL.

  \begin{examples}
    \ex{(cons 'a 'b)}{(a .\ b)}
    \ex{(const 'a '(b))}{(a b)}
    \ex{(cons)}{(nil)}
  \end{examples}
\end{defun}

\begin{defun}{Function}{(length $l$)}
  Returns the length of the list $l$.
\end{defun}

\begin{defun}{Function}{(list \xargs)}
  Create a list of the items \largs
\end{defun}

\begin{defun}{Function}{(nconc \xargs)}
  Same as \lisp{append} but modifies the arguments \largs
\end{defun}

\begin{defun}{Function}{(nth $x$ $n$)}
  Returns the $n$th tail of $x$. Returns \NIL\ if there are fewer
  elements in $x$ than $n$.

  \begin{examples}
    \ex{(nth '(a b c) 2)}{(b c)}
    \ex{(nth '(a b c) 4)}{nil}
  \end{examples}
\end{defun}

\begin{defun}{Function}{(memb $x$ $y$)}
  Looks for an element $x$ in $y$ using \lisp{eq}, returning the tail
  with that element at the head. Returns \NIL\ if not found.

  \begin{examples}
    \ex{(memb 'a '(a b c))}{(a b c)}
    \ex{(memb 'b '(a b c))}{(b c)}
    \ex{(memb 'd '(a b c))}{nil}
  \end{examples}

\end{defun}


\begin{defun}{Function}{(rplaca $x$ $y$)}
  Replaces \lisp{car} of $x$ with $y$ destructively.
\end{defun}

\begin{defun}{Function}{(rplacd $x$ $y$)}
  Replaces \lisp{cdr} of $x$ with $y$ destructively.
\end{defun}

\begin{defun}{Function}{(tconc $l$ $o$)}
  The \lisp{car} of $l$ is a list and the \lisp{cdr} of $l$ is a
  pointer to the first element of the list.  The object $o$ is added
  to the end of the list and the \lisp{cdr} is updated.  An empty $l$
  should be \lisp{(nil}) but if $l$ is \NIL\ it is initialized to
  \lisp{((o) o)}.  All pointers to $l$ points to the new list since
  the changes are destructive.
\end{defun}

\subsection{Functions to Function and Evaluate Functions}

\begin{defun}{Function}{(apply $fn$ $l$)}
  Applies the function $fn$ to the arguments in the list $l$ as if
  $fn$ is called with the list as its arguments.

  \example{(apply car '((a b c)))}{a}
\end{defun}

\begin{defun}{NoSpread Function}{(apply* fn \xargs)}
  A nospread version of \lisp{apply}.

  \example{(apply* car '(a b c))}{a}
\end{defun}

\begin{defun}{Function}{(closure $f$ $v$)}
  \label{closure}
  Eval function that forms the closure of function $f$, with variables
  listed in $v$ statically bound.  This is close to function in other
  lisp dialects. Any closure that is created within another closure
  and lists a variable contained in that closure refers to the same
  variable. This makes it possible for two closures to share one or
  more variables.

  Here is an example of defining a simple function which maintains the
  balance of a bank account.

  \begin{lstlisting}[numbers=left,numberstyle=\tiny]
(defineq
  (make-account
   (lambda (balance)
     ((closure
          '(progn
            (setq withdraw
             (closure
                 (lambda (amount)
                   (setq balance (difference balance amount)))
                 '(balance)))
            (setq deposit
             (closure
                 (lambda (amount)
                   (setq balance (plus balance amount)))
                 '(balance)))
            (lambda ()
              (closure
                  (lambda (m)
                    (cond
                      ((eq m 'withdraw) withdraw)
                      ((eq m 'deposit) deposit)
                      (t nil)))
                  '(withdraw deposit))))
          '(balance withdraw deposit))))))
  \end{lstlisting}

  The function \lisp{make-account} creates and returns a closure
  object which binds the three symbols on line 24 in their lexical
  scope. It sets the symbols \lisp{withdraw} and \lisp{deposit} each
  to a closure over \lisp{balance} with a lambda expression which
  subtracts or adds an \lisp{amount} to the \lisp{balance}.
\end{defun}


\begin{defun}{Function}{(define $x$)}
  Functions functions according to $x$. Each element of the list $x$
  is a list of the form \lisp{(name args .\ body)}. The list is
  evaluated.
\end{defun}

\begin{defun}{NLambda NoSpread Function}{(defineq $x$ $\cdots$)}
  Functions functions according to the list $x$. Each element of the
  list $x$ is of the form \lisp{(name def)} where name is the name of
  the function and the def is a lambda expression.

  \example{(defineq (double (lambda (x) (times 2 x))))}{(double)}
\end{defun}

\begin{defun}{Function}{(eval $e$)}
  Evaluate the expression $e$.
\end{defun}

\begin{defun}{Function}{(evaltrace $n$)}
  Sets the trace variable to $n$. If $n$ is greater than zero the
  interpreter will print some more details on how expressions are
  evaluated. Call \lisp{evaltrace} with a zero argument to turn off
  the tracing.
\end{defun}

\begin{defun}{NLambda Function}{(e $x$)}
  Nlambda version of \lisp{eval}. Evaluates $x$. To illustrate the
  difference between the functions \lisp{eval} and \lisp{e}:

  \begin{examples}
    \ex{(setq f '(plus 1 2))}{(plus 1 2)}
    \ex{(e f)}{(plus 1 2)}
    \ex{(eval f)}{3}
  \end{examples}

\end{defun}

\begin{defun}{Function}{(getrep $x$)}
  Returns the function definition of a \lisp{lambda} or a
  \lisp{nlambda} function object. Calling \lisp{getrep} on any other
  type of object (including \lisp{subr} and \lisp{fsubr}) returns
  \NIL.

  \begin{examples}
    \ex{(defineq (double (lambda (x) (times 2 x))))}{(double)}
    \ex{(getrep double)}{(lambda (x) (times 2 x))}
    \ex{double}{\#<lambda 7fec0a810ce0>}
    \ex{(getrep apply)}{nil}
  \end{examples}

\end{defun}


\begin{defun}{Function}{(lambda $x$ .\ $y$)}
  Creates a lambda object. The parameter $x$ is the parameters of the
  function being defined. If it's a list of atoms the function is a
  spread function, if it's a single atoms the function is a nospread
  function, if it's dotted pair the function is a half spread
  function.

  A ``spread'' function binds each formal parameter to the actual
  parameters when the function is called. Any excess parameter is
  ignored and any missing actual parameter is bound to \NIL.

  A ``nospread'' function binds the formal parameter to a list of all
  actual parameters when called.

  A ``half spread'' function is a combination of the above where the
  actual parameters are bound to each formal parameter and any excess
  actual parameters are bound to the formal parameter in the
  symbol in the \lisp{cdr} of the list of formal parameters.
\end{defun}

\begin{defun}{Function}{(nlambda $x$ .\ $y$)}
  Same as \lisp{lambda} except that the function object is an nlambda
  function object and parameters are not evaluated when the function
  is called.
\end{defun}

\begin{defun}{Function}{(prog1 \xargs)}
  Evaluate each expression in sequence, returning the result of the
  first expression.
\end{defun}

\begin{defun}{Function}{(progn \xargs)}
  Similar to \lisp{prog1} but instead the value of the last expression
  is returned.
\end{defun}


\begin{defun}{NLambda Function}{(quote $x$)}
  Returns $x$ unevaluated.
\end{defun}

\subsection{Predicates}

\begin{defun}{Function}{(atom $x$)}
  Predicate which is true if $x$ is an atom, either a symbol or a
  number. Strings, for example, are not atoms.
\end{defun}

\begin{defun}{Function}{(boundp $x$)}
  Evaluates to \T\ if $x$ is not bound to a value. Note that the
  argument $x$ is evaluated.

  \example{(boundp 'x)}{\T}

  if x is not bound to a value.
\end{defun}

\begin{defun}{Function}{(eq $x$ $y$)}
  Returns \T\ if $x$ is the same object as $y$.
\end{defun}

\begin{defun}{Function}{(eqp $x$ $y$)}
  If both $x$ and $y$ are numbers then \lisp{eqp} returns \T\ if the
  numbers are the same, otherwise return the \lisp{(eq $x$ $y$)}.
\end{defun}

\begin{defun}{Function}{(equal $x$ $y$)}
  Return \T\ if $x$ and $y$ are \lisp{eq}, or if $x$ and $y$ are
  \lisp{eqp}, or if $x$ and $y$ are \lisp{strequal}, or if $x$ and $y$
  are lists \lisp{(and (equal (car $x$) (car $x$)) (equal (cdr $x$)
    (cdr $y$)))}.
\end{defun}

\begin{defun}{Function}{(geq $x$ $y$)}
  \T\ if $x \ge y$, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(greaterp $x$ $y$)}
  \T\ if $x > y$, otherwise \NIL.
\end{defun}


\begin{defun}{Function}{(leq $x$ $y$)}
  \T\ if $x \le y$, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(lessp $x$ $y$)}
  \T\ if $x < y$, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(listp $x$)}
  \T\ if $x$ is a list, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(litatom $x$)}
  \T\ if $x$ is a literal atom, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(neq $x$ $y$)}
  \T\ if $x$ is not \lisp{eq} to $y$, otherwise \NIL. Equivalent to
  \lisp{(not (eq $x$ $y$))}.
\end{defun}

\begin{defun}{Function}{(neqp $x$ $y$)}
  \T\ if $x$ is not \lisp{eqp} to $y$, otherwise \NIL. Equivalent to
  \lisp{(not (eqp $x$ $y$))}.
\end{defun}

\begin{defun}{Function}{(nlistp $x$)}
  \T\ if $x$ is not a list, otherwise \NIL. Same as \lisp{(not (listp
    $x$))}.
\end{defun}

\begin{defun}{Function}{(null $x$)}
  \T\ if $x$ is \NIL, otherwise \NIL.
\end{defun}

\begin{defun}{Function}{(symbolp $x$)}
  Same as \lisp{(litatom $x$)}.
\end{defun}

\begin{defun}{Function}{(zerop $x$)}
  \T\ if $x$ is zero, otherwise \NIL.
\end{defun}

\subsection{Property List Functions}
\lips\ supports property lists on literal atoms. A property list is a
list of values stored in the ``property cell'' of a literal atom. A
property list is list of alternating properties and values. For
example the property list \lisp{(a 1 b 2)} has two properties \lisp{a}
and \lisp{b} with the values \lisp{1} and \lisp{2}
respectively. \lisp{eq} is used to compare properties when
manipulating the property list with the below functions.

\begin{defun}{Function}{(getplist $a$)}
  Returns the entire property list stored in the property cell of $a$.
\end{defun}


\begin{defun}{Function}{(getprop $a$ $p$)}
  Returns the value of property $p$ stored in the property cell of the
  literal atom $a$.
\end{defun}

\begin{defun}{Function}{(putprop $a$ $p$ $v$)}
  Puts the value $v$ in the property $p$ of $a$.
\end{defun}

\begin{defun}{Function}{(remprop $a$ $p$)}
  Removes the property $p$ from the literal atom $a$.
\end{defun}

\begin{defun}{Function}{(setplist $a$ $pl$)}
  Sets the property list of $a$ to $pl$.
\end{defun}

\subsection{Input and Output Functions}
All output functions taking a file descriptor $f$ as a parameter
operates on the primary output if $f$ is \NIL, or on primary error if
$f$ is \T, otherwise $f$ must be a file handle open for writing.

For input functions the file descriptor $f$ is instead primary input
if $f$ is \NIL, stdin if $f$ is \T, or a file handle of a file open
for reading.

\begin{defun}{Function}{(close $f$)}
  Closes the file associated with f.
\end{defun}

\begin{defun}{Function}{(load $fn$)}
  Loads a file, evaluating each s-expression.
\end{defun}

\begin{defun}{Function}{(open $fn$)}
  Open a file.
\end{defun}

\begin{defun}{Function}{(print)}
  Print in such a way that whatever is printed can be read back by the
  interpreter. This means including double quotes around strings and
  quoting special characters with backslashes.
\end{defun}


\begin{defun}{Function}{(prin1 $x$ $f$)}
  Prints the arguments without escapes, i.e. strings are printed
  without surrounding double quotes, and without a terminating
  newline.
\end{defun}

\begin{defun}{Function}{(prin2 \xargs)}
  Same as \lisp{print} but without a terminating newline.
\end{defun}

\begin{defun}{Function}{(printlevel)}
  Specifies how deep printing should go.
\end{defun}

\begin{defun}{Function}{(ratom $f$)}
  Read an atom from $f$.
\end{defun}

\begin{defun}{Function}{(read $f$)}
  Read an S-expression from $f$.
\end{defun}

\begin{defun}{Function}{(readc $f$)}
  Read one character from $f$.
\end{defun}

\begin{defun}{Function}{(readline $f$)}
  Read a line up to a newline from $f$.
\end{defun}

\begin{defun}{Function}{(spaces $n$ $f$)}
  Print $n$ spaces to $f$.
\end{defun}

\begin{defun}{Function}{(terpri $f$)}
  Print a newline to $f$.
\end{defun}

\subsection{Conditionals and Control Functions}

\begin{defun}{Function}{(cond (p$_{1}$ e$_{1}$ $\cdots$) (p$_{2}$ e$_{2}$ $\cdots$)
    $\cdots$)} The predicates p$_{n}$ are evaluated in order
  and the first that is evaluated to anything other than \NIL, the
  expressions after that predicate is evaluated.  The last expression
  evaluated is returned as in progn.  If no predicate evaluates to
  non-\NIL, \NIL\ is returned.
\end{defun}


\begin{defun}{NLambda Function}{(if $p$ $t$ . $f$)}
  If the predicate $p$ evaluates to a non-\NIL\ value the expression
  $t$ is evaluated and returned from the function. If $p$ evaluates to
  \NIL\ then the value of the expression $f$ is returned.
\end{defun}

\begin{defun}{NLambda Function}{(while $p$ \xargs)}
  While the predicate $p$ evaluates to a non-\NIL\ value the sequence
  of expressions \largs are evaluated in sequence. \lisp{while} always
  returns \NIL.
\end{defun}

\subsection{Map Functions}
Map functions iterate over a list of items and applies a function to
either each item or each tail of the list.

\begin{defun}{Function}{(map $list$ $fn_{1}$ $fn_{2}$)}
  If $fn_{2}$ is \NIL, apply the function $fn_{1}$ on each tail of
  $list$. First $fn_{1}$ is applied to $list$, then \lisp{(cdr list)},
  and so on. If $fn_{2}$ is not \NIL\ then $fn_{2}$ is called instead
  of \lisp{cdr} to get the next value on which to apply $fn_{1}$.
  \lisp{map} returns \NIL.

  \begin{quote}
    \lisp{$\leftarrow$(map '(a b c) (lambda (l) (print l)))}\\
    \lisp{(a b c)}\\
    \lisp{(b c)}\\
    \lisp{(c)}\\
    \NIL
  \end{quote}

\end{defun}

\begin{defun}{Function}{(mapc $list$ $fn_{1}$ $fn_{2}$)}
  \lisp{mapc} is the same as \lisp{map} except that $fn_{1}$ is
  applied to \lisp{(car list)} instead of the list. Effectively
  applying $fn_{1}$ on each element of the list. \lisp{mapc} returns
  \NIL.
\end{defun}


\begin{defun}{Function}{(maplist $list$ $fn_{1}$ $fn_{2}$)}
  The same as \lisp{map} but collects the results from applying
  $fn_{1}$ on each tail and returning a list of the results.

  \example{(maplist '(a b c) (lambda (l) (length l)))}{(3 2 1)}
\end{defun}

\begin{defun}{Function}{(mapcar $list$ $fn_{1}$ $fn_{2}$)}
  Equivalent to \lisp{mapc} but collects the results in a list like
  \lisp{maplist}.

  \example{(mapcar '(1 2 3) (lambda (n) (plus n 1)))}{(2 3 4)}
\end{defun}

\subsection{Special Functions}

\begin{defun}{Function}{(baktrace)}
  Prints a backtrace of the evaluation stack when called.
\end{defun}

\begin{defun}{Function}{(exit $code$)}
  Throws the exception \cpp{lisp::lisp\_finish} which contains the
  member variable \cpp{exit\_code}.  This member variable is set to
  the value of $code$. The main function of the C++ program should
  catch this exception and call \cpp{exit(ex.exit\_code)}.
\end{defun}

\begin{defun}{Function}{(freecount)}
  Returns the number of free cons cells available. Since
  \lips\ doesn't manage memory with garbage collection this value is
  rather useless.
\end{defun}

\begin{defun}{Function}{(topofstack)}
  Returns the current environment.
\end{defun}

\begin{defun}{Function}{(destblock $e$)}
  Returns the destination block from an environment. Here is an
  example showing the destination block in some cases.
  \begin{examples}
    \ex{(setq a 88)}{88}
    \ex{(defineq\\
      \hspace*{3mm}(f0 (lambda (a) (destblock (topofstack))))\\
      \hspace*{3mm}(f1 (lambda (a) (f0 a))))}{(f0 f1)}
    \ex{(f1 99)}{(1 (a . 99))}
    \ex{(f0 101)}{(1 (a . 88))}
  \end{examples}
\end{defun}


\begin{defun}{Function}{(typeof $x$)}
  Returns a literal atom describing the data type of $x$.

  \begin{examples}
    \ex{(typeof 'a)}{symbol}
    \ex{(typeof 100)}{integer}
    \ex{(typeof nil)}{nil}
    \ex{(typeof t)}{t}
    \ex{(typeof 1.0)}{float}
    \ex{(typeof "string")}{string}
  \end{examples}

\end{defun}

\begin{defun}{Function}{(obarray)}
  Returns a list of all literal atoms
  currently active in the system.
\end{defun}

\subsection{Shell Functions}
This section describes functions which implement shell features like
output redirection, changing the working directory, job control, etc.

All functions that in some way redirects its input or output are
executed in a fork.  This means that redirecting I/O of a lisp
function doesn't make permanent changes to the \lips\ environment.  No
global variables are changed.

All functions in this section are nlambda functions.

\begin{defun}{NLambda Function}{(cd $d$)}
  Changes current working directory to $d$.
\end{defun}


\begin{defun}{NLambda Function}{(redir-to $cmd$ $file$ $fd$)}
  Evaluates the expression $cmd$, redirecting the output from this
  expression to a file with the file name $file$. The third parameter
  $fd$ is optional and if given should be the file descriptor to
  redirect. The default is to redirect stdout.
\end{defun}

\begin{defun}{NLambda Function}{(redir-from $cmd$ $file$ $fd$)}
  Evaluates the expression $cmd$, redirecting the file descriptor $fd$
  (or stdin if not given) from the file $file$.
\end{defun}

\begin{defun}{NLambda Function}{(append-to $cmd$ $file$ $fd$)}
  Same as \lisp{redir-to} but append to the file $file$ instead of
  overwriting it.
\end{defun}

\begin{defun}{NLambda Function}{(pipe-cmd \xargs)}
  Connects the stdout of $x_{1}$ to stdin of $x_{2}$ and stdout of
  $x_{2}$ to stdin of $x_{3}$ and so on. If there is only one
  expression it is simply evaluated.
\end{defun}

\begin{defun}{NLambda Function}{(back $cmd$)}
  Creates a new process and evaluates the command $cmd$ in this
  process. A new job is created which can be controlled by the job
  controlling functions.
\end{defun}

\begin{defun}{NLambda Function}{(stop)}
  Sends a stop signal to itself.
\end{defun}

\begin{defun}{NLambda Function}{(rehash)}
  \lips\ keeps a hash of all executable files in the \lisp{path} so
  that it can fail fast if a program is not available. The
  \lisp{rehash} function rebuilds this hash in order to pick up new
  programs.
\end{defun}

\begin{defun}{NLambda Function}{(jobs)}
  Lists all jobs currently in flight.
\end{defun}

\begin{defun}{NLambda Function}{(fg $job$)}
  Brings the job $job$ running
  in the background to the foreground.
\end{defun}

\begin{defun}{NLambda Function}{(bg $job$)}
  Continues the job $job$ in the background.
\end{defun}

\begin{defun}{NLambda Function}{(setenv $var$ $val$)}
  Sets the environment variable $var$ to the value $val$.
\end{defun}

\begin{defun}{NLambda Function}{(getenv $var$)}
  Returns the value of the environment varable $var$ or \NIL\ if the
  variable is not set.
\end{defun}

\begin{defun}{NLambda Function}{(exec $cmd$)}
  Replaces the current process with $cmd$.
\end{defun}
