%
% Copyright 2022 Krister Joas
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%     http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%
\section{Using \lips\ as an Embedded Lisp Interpreter}
\subsection{Basic Usage}
The most basic types in \lips\ are the following.
\begin{itemize}
  \item \cpp{lisp::lisp} The lisp interpreter. There may be more than
    one lisp interpreter in the same program. They all share a global
    symbol table which contains the atoms referring to the primitive
    lisp functions. Each interpreter has a local symbol table used for
    variables.
  \item \cpp{LISPT} This is a basic type which can contain a value of
    several fundamental types. \cpp{LISPT} is a pointer to a reference
    counted object of type \cpp{lisp\_t}.
\end{itemize}

The \cpp{lisp\_t} type can contain values of the following types.

\begin{itemize}
  \item[\cpp{NIL}] This is the value \lisp{nil} which also happens to be the
    \cpp{nullptr} value of \cpp{LISPT}.
  \item[\cpp{T}] The truth value. The symbol \lisp{t} will be set to the type
    \cpp{T}.
  \item[\cpp{EMPTY}] No value.
  \item[\cpp{SYMBOL}] A literal atom.
  \item[\cpp{INTEGER}] An integer number. This is a 64 bit integer.
  \item[\cpp{FLOAT}] A double floating point number.
  \item[\cpp{INDIRECT}]
  \item[\cpp{CONS}] A cons cell.
  \item[\cpp{STRING}] A string.
  \item[\cpp{SUBR}] A compiled function which evaluates its
    arguments.
  \item[\cpp{FSUBR}] A compiled function which does not evaluate its
    arguments.
  \item[\cpp{LAMBDA}] A lambda function.
  \item[\cpp{NLAMBDA}] An nlambda function.
  \item[\cpp{CLOSURE}] A static binding.
  \item[\cpp{UNBOUND}] Represents an unbound value.
  \item[\cpp{ENVIRON}] Internal environment stack type.
  \item[\cpp{FILET}] A file object.
  \item[\cpp{FREE}] A marker for an object that has been freed. Used to
    detect if an object being allocated is truly not in use.
  \item[\cpp{ENDOFFILE}] End of file marker.
  \item[\cpp{ERROR}] Returned from primitive functions to indicate an
    error condition.
  \item[\cpp{CVARIABLE}] A \textsf{C++} variable which can be accessed
    and changed from both \textsf{C++} and from a lisp expression.
\end{itemize}

To check the type you can use the \cpp{type\_of} function which
returns a class enum of type \cpp{lisp::type}. Not all types have an
actual value, e.g. \cpp{NIL}, \cpp{T}, \cpp{UNBOUND}, etc.

If you have a value of type \cpp{lisp\_t} (always indirectly via a
\cpp{LISPT} pointer) you can get the actual value using various getter
functions and set the value with setter functions. There is no type
checking when in the getters so calling a getter with the wrong type
results in an exception.

\begin{itemize}
  \item \cpp{auto symbol() -> symbol::symbol\_t\&}
\end{itemize}

There are some literals which simplify creating lisp
objects. \cpp{operator""\_s} creates a string, \cpp{operator""\_a}
creates a literal atom, \cpp{operator""\_l} creates a number or a
floating point value depending on the argument type. Finally the
\cpp{operator""\_e} evaluates a string as a lisp expression and returns
the result of the evaluation.

\begin{lstlisting}[language=c++]
#include <lisp/lisp.hh>

int main()
{
  // Create a lisp interpreter.
  lisp::lisp lisp;
  // The _l suffix creates a lisp object by parsing
  // the string.
  lisp::print(lisp::cons("a"_l, "b"_l)); // => (a . b)
}
\end{lstlisting}
\subsection{The REPL}
\cpp{lisp::repl} is an object which has an \cpp{LISPT
  operator()(LISPT)} which implements a simple read, eval, and print
loop.  The \cpp{lisp::lisp} object has a member variable called
\cpp{repl} which is a function taking a \cpp{LISPT} type object and
returns a \cpp{LISPT} type object.

Typical usage.

\begin{lstlisting}[language=c++]
  lisp::lisp lisp;
  lisp::repl repl(lisp);
  lisp.repl = [&repl](lisp::LISPT) -> lisp::LISPT { return
    repl(lisp::NIL); };
  lisp.repl(lisp::NIL);
\end{lstlisting}

If the evaluation of an expression results in a break condition,
i.e. the evaluation cannot continue due to an error, then the
\cpp{lisp::lisp::repl} function is called recursively. The
\cpp{lisp::repl} class recognizes some simple commands which allows
the state to be examined or evaluation to continue, possibly after
some changes to the environment or the program.

\subsection{Input/Output}
Input and output is handled with base classes called \cpp{source} and
\cpp{sink}. A \cpp{source} needs to implement the following pure
virtual functions.

\begin{description}
  \item[\cpp{int}] \cpp{getch()} \\ Read one character from the input source.
  \item[\cpp{void}] \cpp{ungetch(int)} \\ Put a character back on the input
    stream to be read next time \cpp{getch} is called.
  \item[\cpp{bool}] \cpp{close()} \\ Close the input source.
  \item[\cpp{std::optional<std::string>}] \cpp{getline()} \\ Read one line
    from the input source. Returns an empty optional at end of file.
  \item[\cpp{iterator}] \cpp{begin()} \\ Returns an iterator which when
    incremented reads the next character from the source.
\end{description}

A \cpp{sink} needs to override the following pure virtual functions.

\begin{description}
  \item[\cpp{void}] \cpp{putch(int, bool)} \\ Puts one character on
    the output stream. If the second bool parameter is \cpp{true} then
    characters are quoted with a backslash if non-printable.
  \item[\cpp{void}] \cpp{puts(const std::string\_view)} \\ Puts a
    string on the output stream.
  \item[\cpp{void}] \cpp{terpri()} \\ Prints a newline.
  \item[\cpp{void}] \cpp{flush()} \\ Flushes the sink.
  \item[\cpp{bool}] \cpp{close()} \\ Closes the sink.
\end{description}

Several sources and sinks are predefined.

\begin{description}
  \item[file\_source] The source is an existing file. The constructor
    takes a file name as its argument.
  \item[stream\_source] The stream source takes a \cpp{std::istream}
    as its argument.
  \item[string\_source] The string sources takes a \cpp{std::string}
    as its argument.
  \item[file\_sink] Takes a file name as its first argument. The
    second argument is a \cpp{bool} where \cpp{true} means append
    mode.
  \item[stream\_sink] Accepts a \cpp{std::ostream} as its argument.
  \item[string\_sink] Takes no argument. The data written to the
    string can be retrieved by calling the
    \cpp{string\_sink::string()} member function.
\end{description}

\subsection{Sharing Variables Between \lips\ and \textsf{C++}}
The type \cpp{cvariable\_t} is a class which enables sharing a
variable of type \cpp{LISPT} between lisp and \textsf{C++}.

\subsection{Adding New Primitives}
It's possible to create new primitive functions, functions which are
registered with the lisp interpreter and are callable a lisp
program. Registering a new primitive is done using the
\cpp{lisp::mkprim} function. \cpp{lisp::mkprim} takes four
arguments. The first is a string which is the literal atom to which
the function is bound. The second argument is a \textsf{C++} function
which takes a lisp interpreter and zero, one, two, or three
\cpp{LISPT} values and returns a \cpp{LISPT} value. It can be a lambda
function.  The third and fourth argument specifies if the function
should evaluate it's argument or not and if the function is a spread
or a no spread function.

Here is an example of defining a function called \lisp{printall} which
takes any number of arguments and prints them.

\begin{lstlisting}[language=c++]
  mkprim(
    "printall",
    [&result](lisp& l, LISPT a) -> LISPT {
      for(auto p: a)
      {
        print(p);
      }
      terpri();
      return NIL;
    },
    subr_t::subr::NOEVAL, subr_t::spread::NOSPREAD);
\end{lstlisting}
