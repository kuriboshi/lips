%
% Copyright 2022-2023 Krister Joas
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%     http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%
\section{Using \lips\ as an Embedded Lisp Interpreter}
\subsection{Basic Usage}
The most basic types in \lips\ are the following.
\begin{itemize}
  \item \cpp{lisp::vm} The lisp interpreter, or virtual machine. There
    may be only one lisp interpreter in the same program.
  \item \cpp{lisp::context} The context contains some globally
    accessable values mostly related to I/O such as the current
    primary output or primary error. Currently there can be only one
    context per program.
  \item \cpp{lisp\_t} This is a basic type which can contain a value
    of several fundamental types. \cpp{lisp\_t} is a pointer to a
    reference counted object of type \cpp{object}.
\end{itemize}

The \cpp{object} type can contain values of the following types.

\begin{itemize}
  \item[\cpp{Nil}] This is the value \lisp{nil} which also happens to be the
    \cpp{nullptr} value of \cpp{lisp\_t}.
  \item[\cpp{Symbol}] A literal atom.
  \item[\cpp{Integer}] An integer number. This is a 64 bit integer.
  \item[\cpp{Float}] A double floating point number.
  \item[\cpp{Indirect}] Used in a closure.
  \item[\cpp{Cons}] A cons cell consisting of two \cpp{lisp\_t} values.
  \item[\cpp{String}] A string.
  \item[\cpp{Subr}] A compiled (\textsf{C++}) function. A compiled
    function may be spread or no spread and it may evaluate its
    arguments or not (fsubr). A compiled function may have zero to
    three arguments.
  \item[\cpp{Lambda}] A lambda function. As with a compiled function a
    lambda may be a spread or a no spread function and it may evaluate
    or not evaluates its arguments (nlambda).
  \item[\cpp{Closure}] A static binding.
  \item[\cpp{Environ}] Internal environment stack type.
  \item[\cpp{File}] A file object.
  \item[\cpp{Cvariable}] A \textsf{C++} variable which can be accessed
    and changed from both \textsf{C++} and from a lisp expression.
\end{itemize}

To check the type you can use the \cpp{type\_of} function which
returns a class enum of type \cpp{lisp::object::type}.

If you have a value of type \cpp{object} (always indirectly via a
\cpp{lisp\_t} pointer) you can get the actual value using various
getter functions and set the value with setter functions. There is no
type checking when in the getters so calling a getter with the wrong
type results in an exception.

\begin{itemize}
  \item \cpp{auto symbol() const -> symbol::ref\_symbol\_t} The literal atom.
  \item \cpp{auto value() const -> lisp\_t} Returns the value of a literal
    atom.
  \item \cpp{void value(lisp\_t)} Set the value of a literal atom.
  \item \cpp{auto intval() const -> std::int64\_t} Returns the 64 bit
    integer value.
  \item \cpp{auto floatval() const -> double} Returns the floating
    point value.
  \item \cpp{auto indirect() const -> lisp\_t} Returns the real
    value of the indirect value.
  \item \cpp{auto cons() const -> const cons\_t\&} Returns the cons
    cell.
  \item \cpp{auto car() const -> lisp\_t} Returns the \lisp{car} of
    the cons cell.
  \item \cpp{void car(lisp\_t)} Sets the \lisp{car} of the cons cell.
  \item \cpp{auto cdr() -> lisp\_t} Returns the \lisp{cdr} of
    the cons cell.
  \item \cpp{void cdr(lisp\_t)} Sets the \lisp{cdr} of the cons cell.
\end{itemize}

There are some literals which simplify creating lisp
objects. \cpp{operator""\_s} creates a string, \cpp{operator""\_a}
creates a literal atom, \cpp{operator""\_l} creates a number or a
floating point value depending on the argument type. Finally the
\cpp{operator""\_e} evaluates a string as a lisp expression and returns
the result of the evaluation.

\begin{lstlisting}[language=c++]
#include <lisp/lisp.hh>

int main()
{
  // Create the context.
  lisp::context ctx;
  // Create the lisp interpreter.
  lisp::vm vm(ctx);
  // The _l suffix creates a lisp object by parsing
  // the string.
  lisp::print(lisp::cons("a"_a, "b"_a)); // => (a . b)
}
\end{lstlisting}
\subsection{The REPL}
\cpp{lisp::repl} is an object which has an \cpp{lisp\_t
  operator()(lisp\_t)} which implements a simple read, eval, and print
loop.  The \cpp{lisp::vm} object has a member variable called
\cpp{repl} which is a function taking a \cpp{lisp\_t} type object and
returns a \cpp{lisp\_t} type object.

Typical usage.

\begin{lstlisting}[language=c++]
  lisp::context ctx;
  lisp::vm vm(ctx);
  lisp::repl repl(vm);
  lisp.repl = [&repl](lisp::lisp_t) -> lisp::lisp_t
  {
    return repl(lisp::NIL);
  };
  lisp.repl(lisp::NIL);
\end{lstlisting}

If the evaluation of an expression results in a break condition,
i.e. the evaluation cannot continue due to an error, then the
\cpp{lisp::vm::repl} function is called recursively. The
\cpp{lisp::repl} class recognizes some simple commands which allows
the state to be examined or evaluation to continue, possibly after
some changes to the environment or the program.

\subsection{Input/Output}
Input and output is handled with base classes called \cpp{source} and
\cpp{sink}. A \cpp{source} needs to implement the following pure
virtual functions.

\begin{description}
  \item[\cpp{int}] \cpp{getch()} \\ Read one character from the input source.
  \item[\cpp{void}] \cpp{ungetch(int)} \\ Put a character back on the input
    stream to be read next time \cpp{getch} is called.
  \item[\cpp{bool}] \cpp{close()} \\ Close the input source.
  \item[\cpp{std::optional<std::string>}] \cpp{getline()} \\ Read one line
    from the input source. Returns an empty optional at end of file.
  \item[\cpp{iterator}] \cpp{begin()} \\ Returns an iterator which when
    incremented reads the next character from the source.
\end{description}

A \cpp{sink} needs to override the following pure virtual functions.

\begin{description}
  \item[\cpp{void}] \cpp{putch(int, bool)} \\ Puts one character on
    the output stream. If the second bool parameter is \cpp{true} then
    characters are quoted with a backslash if non-printable.
  \item[\cpp{void}] \cpp{puts(const std::string\_view)} \\ Puts a
    string on the output stream.
  \item[\cpp{void}] \cpp{terpri()} \\ Prints a newline.
  \item[\cpp{void}] \cpp{flush()} \\ Flushes the sink.
  \item[\cpp{bool}] \cpp{close()} \\ Closes the sink.
\end{description}

Several sources and sinks are predefined.

\begin{description}
  \item[file\_source] The source is an existing file. The constructor
    takes a file name as its argument.
  \item[stream\_source] The stream source takes a \cpp{std::istream}
    as its argument.
  \item[string\_source] The string sources takes a \cpp{std::string}
    as its argument.
  \item[file\_sink] Takes a file name as its first argument. The
    second argument is a \cpp{bool} where \cpp{true} means append
    mode.
  \item[stream\_sink] Accepts a \cpp{std::ostream} as its argument.
  \item[string\_sink] Takes no argument. The data written to the
    string can be retrieved by calling the
    \cpp{string\_sink::string()} member function.
\end{description}

\subsection{Sharing Variables Between \lips\ and \textsf{C++}}
The type \cpp{cvariable\_t} is a class which enables sharing a
variable of type \cpp{lisp\_t} between lisp and \textsf{C++}.

\subsection{Adding New Primitives}
It's possible to create new primitive functions, functions which are
registered with the lisp interpreter and are callable a lisp
program. Registering a new primitive is done using the
\cpp{lisp::mkprim} function. \cpp{lisp::mkprim} takes four
arguments. The first is a string which is the literal atom to which
the function is bound. The second argument is a \textsf{C++} function
which takes a lisp interpreter and zero, one, two, or three
\cpp{lisp\_t} values and returns a \cpp{lisp\_t} value. It can be a lambda
function.  The third and fourth argument specifies if the function
should evaluate it's argument or not and if the function is a spread
or a no spread function.

Here is an example of defining a function called \lisp{printall} which
takes any number of arguments and prints them.

\begin{lstlisting}[language=c++]
  mkprim(
    "printall",
    [&result](lisp\_t a) -> lisp\_t {
      for(auto p: a)
      {
        print(p);
      }
      terpri();
      return NIL;
    },
    subr_t::subr::NOEVAL, subr_t::spread::NOSPREAD);
\end{lstlisting}
